
LINUX DEVICE DRIVERS

This is my notes on programming Linux device drivers.

///////////////////////////////////////////////////////////////////////////

History

	2017/10/25	init

///////////////////////////////////////////////////////////////////////////

References

1. LDD3
1. 宋宝华, Linux设备驱动开发详解:基于最新的Linux4.0内核, 机械工业出版社 2015年8月1日

///////////////////////////////////////////////////////////////////////////

MAKEFILE

= 是最基本的賦值
:= 會覆蓋變數之前的值
?= 變數為空時才給值，不然則維持之前的值
+= 將值附加到變數的後面

///////////////////////////////////////////////////////////////////////////

Kernel Drivers for I2C/SMBus Devices

* may not be necessary since i2c-dev.c prepares such drivers of major number 89. See
```
# ls -l /dev | grep 'i2c'
```

* of built-in type must implement
```
struct I2c_device_id foo_idtable = {
	{"foo", 0}, /* name up to 20 characters, driver_data */
	{} /* end of list */
};
MODULE_DEVICE_TABLE(i2c, foo_idtable);

struct i2c_driver foo_driver = {
	.driver = {
		.name = "foo",
		.owner = THIS_MODULE,
	},

	.id_table = foo_idtable,
	.probe = foo_probe,
	.remove = foo_remove,
}
```

* of autodetection type must implement extra callbacks
```
	.class = I2C_CLASS_SOMETHING,
	.detect = foo_detect,
	.address_list = normal_i2c,
```

* registers during initialization
```
static init __init foo_init(void)
{
	return i2c_add_driver(&foo_driver);
}
module_init(foo_init);

static void __exit foo_exit(void)
{
	return i2c_del_driver(&foo_driver);
}
module_exit(foo_exit);

MODULE_LICENSE("GPL");
```


references:
1. 宋宝华, Linux设备驱动开发详解. section 15.4
1. Documentation/i2c/writing-clients

///////////////////////////////////////////////////////////////////////////

MISCELLANEOUS CHARACTER DRIVERS

	* are not found in LDD3 book
	* have been existing since 2.0 kernel
	* support custom hacks
	* show as character devices with major number 10 with the following commands

# ls -l /dev
# cat /proc/devices

* APIs (kernel 3.18)

#include <linux/miscdevice.h>
struct file_operations foo_fops = {

};
struct miscdevice * foo_dev = {
	.minor	=	MISC_DYNAMIC_MINOR, //a minor number is assigned by kernel
	.name	=	"foo",
	.fops	=	&foo_fops,
};

static init __init foo_init(void)
{
	int ret;
	ret = misc_register(&foo_dev);
	/* TODO: handle error */

	return ret;
}
module_init(foo_init);

static void __exit foo_exit(void)
{
	misc_deregister(&foo_dev);
}
module_exit(foo_exit);


REFERENCES:

	1. Docs » The Linux driver implementer’s API guide » Miscellaneous Devices 
	[link] https://www.kernel.org/doc/html/v4.12/driver-api/misc_devices.html
	
	2. Miscellaneous Character Drivers, Jun 30, 1998  By Alessandro Rubini 
	[link] http://www.linuxjournal.com/article/2920
	
	3. 
	[link] http://nano-chicken.blogspot.tw/2009/12/linux-modules6-miscdev.html
	
	4. misc_register和register_chrdev的区别
	[link] http://blog.csdn.net/armeasy/article/details/7197936
	
///////////////////////////////////////////////////////////////////////////
## Netlink / Netlink sock family
* is a Linux interface used for inter-process communication between both the kernel and userspace processes, and between different userspace processes
* has benefits over other communcations such as system calls, ioctls or proc filesystems
  * is relatively trivial
  * is a full-duplex communication link
  * is asynchronous
  * enables loadable module
  * supports multicast

* uses standard socket APIs for user-space processes
```

```
* uses a special kernel API for kernel modules (kernel 3.18)
```
#include <linux/netlink.h>
struct sock *netlink_kernel_create(struct net *net, int unit, struct netlink_kernel_cfg *cfg);
void netlink_kernel_release(struct sock *sk);

```

references:
  * Wiki [link](https://en.wikipedia.org/wiki/Netlink)
  * Kernel Korner - Why and How to Use Netlink Socket, Jan 05, 2005  By Kevin Kaichuan He [link](http://www.linuxjournal.com/article/7356)
  * Linux中与内核通信的Netlink机制 [link](http://www.linuxidc.com/Linux/2011-07/39085.htm)
